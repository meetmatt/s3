[Оглавление](/README.md) | [Назад](setup.md "Подготовка") | [Далее](tools.md "Инструменты")

# Настройка прокси

В ситуации, когда файл находится на S3, но уже не доступен на нашем сервере, CloudFront, проверив файл на нашем сервере, сразу вернет 404 ошибку и не пойдет искать его на S3.

Этого можно избежать, проверяя в коде существование файла локально, и генерируя ссылку соответственно либо на наш сервер, либо на CDN. Но это потребует объемных изменений.

Чтобы избежать эту проблему, нужно прописать http proxy на нашем сервере.

## Nginx proxy

Нам необходимо, чтобы nginx сначала пытался взять файл локально, а в случае, если файла нет, проксировал запрос на S3.

Для этого укажем путь до прокси в конфиге nginx'а в секции server:

```
http {

	#...
	
	server {
		listen 80;
		server_name example.com www.example.com;
		
		# вместо images надо указать директорию, файлы из которой переносятся на S3
		location ~ ^/images/(.*)$ {
			# сначала файл берется локально и, если он не найден, выполняется директива s3
			try_files $uri @s3;
		}
		
		# выполняется только если файл не найден
		location @s3 {
		
			# вместо example надо указать название реального бакета
			set $s3_host 'example.s3.amazonaws.com';
			set $s3_file '$1';
			
			# для корректной работы необходимо выставить заголовки
			proxy_set_header       Host $s3_host;
			proxy_set_header       Authorization '';
			proxy_hide_header      x-amz-id-2;
			proxy_hide_header      x-amz-request-id;
			proxy_hide_header      Set-Cookie;
			proxy_ignore_headers   "Set-Cookie";
			proxy_buffering        off;
			proxy_intercept_errors on;
			proxy_redirect off;
			
			proxy_pass             http://$s3_bucket/images/$s3_file;
		}
		
		# остальные директивы location
	}
}
```

Перезапускаем конфигурацию nginx'а:

```
$ service nginx reload
```

## Проверка

Заходим в консоль управления S3. В нашем бакете создаем папку images. В нее загружаем файл, которого точно нет на нашем сервере в директории images. Открываем файл по ссылке на CloudFront. Файл должен открыться.

В этот момент CloudFront ищет файл в своем кеше, не обнаруживает его в кеше, посылает запрос на наш сервер, nginx ищет файл локально, не обнаруживает его, отправляет запрос на S3, получает файл и отправляет его обратно CloudFront'у, тот его кеширует и отдает клиенту.

Справедливости ради стоит заметить, что у этой схемы есть очевидный минус - наш сервер отправляет запрос на S3, чтобы забрать файл. Но делает он это только один раз, потому что все следующие разы клиенты получат ответ из кеша CloudFront'а.

Если мы посмотрим в веб-инспектор, то увидим специальный заголовок `X-Cache`, в котором CloudFront указывает, откуда загружен файл - из кеша или из источника. Первый раз файл всегда берется из источника (`X-Cache: Miss from cloudfront`). Перезагрузив страницу в этом заголовке будет значение `X-Cache: Hit from cloudfront`.

## Перенаправление вместо прокси

Чтобы сократить издержки на проксирование запроса от CloudFront'а до S3 и обратно, можно просто перенаправлять запрос. Конфиг в таком случае выглядит так:

```
http {

	#...
	
	server {
		listen 80;
		server_name example.com www.example.com;
		
		location ~ ^/images/(.*)$ {
			try_files $uri @s3redirect;
		}
		
		location @s3redirect {
			return 301 http://example.s3.amazonaws.com/images/$1;		}
		
		# остальные директивы location
	}
}
```

В случае, если файл не найден, nginx ответит CloudFront'у редиректом (301 Moved permanently), CloudFront в свою очередь перенаправит клиента по новому URL'у.

Плюс - мы не тратим траффик на отправку файла CloudFront'у.

Минус - CloudFront закеширует не сам файл, а редирект на него, соответственно клиент получит файл прямиком с S3, который находится в единственном регионе, траффик с S3 дороже и скорость обычно медленнее. Вероятно что это конфигурация в результате окажется дороже, чем использование прокси.

[Оглавление](/README.md) | [Назад](setup.md "Подготовка") | [Далее](tools.md "Инструменты")